package cz.cuni.mff.d3s.jdeeco.visualizer.network;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Each {@link Link} instance represents a link in a Matsim-style network.
 * 
 * <p>
 * Matsim handles ONLY oneway links.  A bidirectional link has to be
 * defined as two unidirectional links.
 * </p>
 * 
 * @author Dominik Skoda <skoda@d3s.mff.cuni.cz>
 *
 */
public class Link {

	/**
	 * The reference to generate next link ID.
	 */
	private static int LINK_ID_REFERENCE = 0;
	
	/**
	 * Each link HAS to have a unique id!
	 * <p>format := unsigned integer</p>
	 * <p>REQUIRED</p>
	 */
	private final int id;
	
	/**
	 * 
	 * Each link HAS to have a from {@link Node}, which is part of the SAME
	 * network category as this link.
	 * <p>format := unsigned integer</p>
	 * <p>REQUIRED</p>
	 */
	private final Node from;
	
	/**
	 * Each link HAS to have a tonode-ID, which is part of the SAME network
	 * category as this link.
	 * <p>format := unsigned integer</p>
	 * <p>REQUIRED</p>
	 */
	private final Node to;
	
	/**
	 * Defines the real length of the link.  It must be (of course)
	 * at least as long as the Euclidean distance between
	 * the from and to nodes.
	 * <p>format := unsigned double</p>
	 * <p>units  := meter</p>
	 * <p>REQUIRED</p>
	 */
	private final double length;
	
	/**
	 * Defines the allowed maximum speed of the link (for street link).
	 * defines the 'fixed' speed of the link (for publictransport links).
	 * defines the 'typical' speed of the link (for pedestrian links).
	 * <p>format := double</p>
	 * <p>units  := meter/seconds</p>
	 * <p>REQUIRED</p>
	 */
	private double freeSpeed;
	
	/**
	 * Defines the maximal capacity of this link for a given period (see
	 * ATTRIBUTE capperiod).
	 * <p>format := double</p>
	 * <p>units  := vehicles/[given period]</p>
	 * <p>REQUIRED</p>
	 */
	private double capacity;
	
	/**
	 * Defines the number of lanes of this link.
	 * <p>format := double</p> 
	 * <p>units  := N/A</p>
	 * <p>REQUIRED</p>
	 */
	private double permLanes;
		
	/**
	* Comma-separated list of transportation modes that are allowed on
	* this link.
	*/
	private List<String> modes;
	
	/** 
	* If available, it is possible to add measured/counted average
	* volume for this link.  It should respect the given period (see
	* capperiod).
	* <p>format := double</p>
	* <p>units  := vehicles/[given period]</p>
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>IMPLIED</p>
	*/
	private double volume;
	
	/**
	* Since other programs (i.e. VISUM) provide bidirectional links,
	* those have to split up into two unidirectional links.  This
	* attribute holds the original id for comparison.
	* <p>format := string</p>
	* <p>units  := N/A</p>
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>IMPLIED</p>
	*/
	private String origId;
	
	/**
	* Sometimes networks provide different kinds of classification.
	* It is possible to keep them there.
	* <p>format := string</p>
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>IMPLIED</p>
	*/
	private String ntCategory;
	
	/**
	* Sometimes networks provide different kinds of classification.
	* It is possible to keep them there.
	* <p>format := string</p>
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>IMPLIED</p>
	*/
	private String ntType;
	
	/**
	* Typically, networks are created by third party (i.e. GIS users).
	* So it makes sense (for completeness) to add the type of the link.
	* Note, sometimes, the type defines in which of the network
	* categories it belongs (streets, pedestrians, publictransport), so
	* be sure, that the type does not conflict with the network
	* category.
	* <p>format := string</p>
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>IMPLIED</p>
	*/
	private String type;
	
	/**
	 * Create a new instance of a {@link Link} connecting the two given nodes.
	 * @param from The node where this link begins.
	 * @param to The node where this link terminates.
	 * @param length The length of the link in meters.
	 */
	public Link(Node from, Node to, double length) {
		id = LINK_ID_REFERENCE++;
		this.from = from;
		this.to = to;
		this.length = length;
		
		init();
	}
	
	/**
	 * Create a new instance of a {@link Link} connecting the two given nodes.
	 * The length of the link is calculated from the distance of the given nodes.
	 * @param from The node where this link begins.
	 * @param to The node where this link terminates.
	 */
	public Link(Node from, Node to) {
		id = LINK_ID_REFERENCE++;
		this.from = from;
		this.to = to;
		
		double dx = Math.pow(from.getX() - to.getX(), 2);
		double dy = Math.pow(from.getY() - to.getY(), 2);
		length = Math.sqrt(dx + dy);

		init();
	}
	
	/**
	 * Initialize the properties of this link to default values.
	 */
	private void init(){
		freeSpeed = 1;
		capacity = 1;
		permLanes = 1;
		modes = new ArrayList<>();
		volume = Double.NaN;
		origId = null;
		ntCategory = null;
		ntType = null;
		type = null;
	}
	
	/**
	 * Get the ID of the link.
	 * @return The ID of the link.
	 */
	public int getId(){
		return id;
	}
	
	/**
	 * Get the node where this link starts.
	 * @return The node where this link starts.
	 */
	public Node getFrom(){
		return from;
	}
	
	/**
	 * Get the node where this link terminates.
	 * @return The node where this link terminates.
	 */
	public Node getTo(){
		return to;
	}
	
	/**
	 * Get the length of this link.
	 * @return The length of this link.
	 */
	public double getLength(){
		return length;
	}

	/**
	 * Defines the allowed maximum speed of the link (for street link).
	 * defines the 'fixed' speed of the link (for publictransport links).
	 * defines the 'typical' speed of the link (for pedestrian links).
	 * <p>This property is required</p>
	 * @param freeSpeed The speed in meter/seconds to be set.
	 * @throws IllegalArgumentException Thrown if the freeSpeed argument
	 * 		is non-positive or zero number.
	 */
	public void setFreeSpeed(double freeSpeed){
		if(!Double.isFinite(freeSpeed)) throw new IllegalArgumentException(
				String.format("The \"%s\" argument is not finite.", "freeSpeed"));
		if(freeSpeed <= 0) throw new IllegalArgumentException(String.format(
				"The \"%s\" argument has to be greater than 0.", "freeSpeed"));
		this.freeSpeed = freeSpeed;
	}
	
	/**
	 * Get the free speed of this link.
	 * @return The free speed of this link.
	 */
	public double getFreeSpeed(){
		return freeSpeed;
	}

	/**
	 * Defines the maximum capacity of this link for a given period.
	 * <p>This property is required.</p>
	 * @param capacity the capacity of this link in vehicles/[given period].
	 * @throws IllegalArgumentException Thrown if the capacity argument
	 * 		is not positive non-zero number.
	 */
	public void setCapacity(double capacity){
		if(!Double.isFinite(capacity)) throw new IllegalArgumentException(
				String.format("The \"%s\" argument is not finite.", "capacity"));
		if(capacity <= 0) throw new IllegalArgumentException(String.format(
				"The \"%s\" argument has to be greater than 0.", "capacity"));
		this.capacity = capacity;
	}
	
	/**
	 * Get the capacity of this link.
	 * @return The capacity of this link.
	 */
	public double getCapacity(){
		return capacity;
	}

	/**
	 * Defines the number of lanes of this link.
	 * <p>This property is required</p>
	 * @param permLanes The number of lanes of this link.
	 * @throws IllegalArgumentException Thrown if the permLanes argument
	 * 		is non-positive or zero number.
	 */
	public void setPermLanes(double permLanes){
		if(!Double.isFinite(permLanes)) throw new IllegalArgumentException(
				String.format("The \"%s\" argument is not finite.", "permLanes"));
		if(permLanes <= 0) throw new IllegalArgumentException(String.format(
				"The \"%s\" argument has to be greater than 0.", "permLanes"));
		this.permLanes = permLanes;
	}
	
	/**
	 * Get the number of lanes of this link.
	 * @return The number of lanes of this link.
	 */
	public double getPermLanes(){
		return permLanes;
	}

	/**
	* Comma-separated list of transportation modes that are allowed on
	* this link.
	* @param mode The mode to be added.
	* @return True if the mode has been added.
	* 		False if the mode was already contained in this link.
	* @throws IllegalArgumentException Thrown if the given mode is null
	* 		or empty string.
	*/
	public boolean addMode(String mode){
		if(mode == null || mode.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is null or empty.", "mode"));
		}
		if(!modes.contains(mode)){
			modes.add(mode);
			return true;
		}
		return false;
	}
	
	/**
	 * Remove the given mode from this link.
	 * @param mode The mode to be removed.
	 * @return True if the mode has been removed.
	 * 		False if the mode has not been found.
	 * @throws IllegalArgumentException Thrown if the given mode is null
	 * 		or empty string.
	 */
	public boolean removeMode(String mode){
		if(mode == null || mode.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is null or empty.", "mode"));
		}
		if(modes.contains(mode)){
			modes.remove(mode);
			return true;
		}
		return false;
	}
	
	/**
	 * Get the modes defined on this link.
	 * @return The modes defined on this link.
	 */
	public List<String> getModes(){
		return Collections.unmodifiableList(modes);
	}

	/** 
	* If available, it is possible to add measured/counted average
	* volume for this link.  It should respect the given period.
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>This property is not required. Can be set to NaN.</p>
	* @param volume The volume of this link as vehicles/[given period].
	 * @throws IllegalArgumentException Thrown if the volume argument
	 * 		is non-positive or zero number.
	*/	
	public void setVolume(double volume){
		if(Double.isInfinite(volume)) throw new IllegalArgumentException(
				String.format("The \"%s\" argument is not finite.", "volume"));
		if(volume <= 0) throw new IllegalArgumentException(String.format(
				"The \"%s\" argument has to be greater than 0.", "volume"));
		this.volume = volume;
	}
	
	/**
	 * Get the volume of this link.
	 * @return The volume of this link.
	 */
	public double getVolume(){
		return volume;
	}

	/**
	* Since other programs (i.e. VISUM) provide bidirectional links,
	* those have to split up into two unidirectional links.  This
	* attribute holds the original id for comparison.
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>This property is not required. Can be set to null.</p>
	* @param origId The original ID of this link.
	* @throws IllegalArgumentException If the origId argument is an empty string.
	*/
	public void setOrigId(String origId){
		if(origId != null && origId.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is empty.", "origId"));
		}
		this.origId = origId;
	}
	
	/**
	 * Get the original ID of this link.
	 * @return The original ID of this link.
	 */
	public String getOrigId(){
		return origId;
	}

	/**
	* Sometimes networks provide different kinds of classification.
	* It is possible to keep them there.
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>This property is not required. Can be set to null.</p>
	* @param ntCategory The category of the link.
	* @thrown {@link IllegalArgumentException} Thrown if the ntCategory is an empty string.
	*/
	public void setNtCategory(String ntCategory){
		if(ntCategory != null && ntCategory.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is empty.", "ntCategory"));
		}
		this.ntCategory = ntCategory;
	}
	
	/**
	 * Get the category of this link.
	 * @return The category of this link.
	 */
	public String getNtCategory(){
		return ntCategory;
	}

	/**
	* Sometimes networks provide different kinds of classification.
	* It is possible to keep them there.
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>This property is not required. Can be set to null.</p>
	* @param ntType The type of the link.
	* @thrown {@link IllegalArgumentException} Thrown if the ntType is an empty string.
	*/
	public void setNtType(String ntType){
		if(ntType != null && ntType.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is empty.", "ntType"));
		}
		this.ntType = ntType;
	}
	
	/**
	 * Get the type of the link.
	 * @return The type of the link.
	 */
	public String getNtType(){
		return ntType;
	}

	/**
	* Typically, networks are created by third party (i.e. GIS users).
	* So it makes sense (for completeness) to add the type of the link.
	* Note, sometimes, the type defines in which of the network
	* categories it belongs (streets, pedestrians, publictransport), so
	* be sure, that the type does not conflict with the network
	* category.
	* <p>This attribute is special one typically generated by VISUM.</p>
	* <p>This property is not required. Can be set to null.</p>
	* @param type The type of the link.
	* @thrown {@link IllegalArgumentException} Thrown if the ntType is an empty string.
	*/
	public void setType(String type){
		if(type != null && type.isEmpty()){
			throw new IllegalArgumentException(String.format(
					"The argument \"%s\" is empty.", "type"));
		}
		this.type = type;
	}
	
	/**
	 * Get the type of the link.
	 * @return The type of the link.
	 */
	public String getType(){
		return type;
	}
	
	/**
	 * Returns the string Matsim XML representation of the link.
	 */
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		
		builder.append("<link ")
			.append("id=\"").append(id).append("\" ")
			.append("from=\"").append(from.getId()).append("\" ")
			.append("to=\"").append(to.getId()).append("\" ")
			.append("length=\"").append(length).append("\" ")
			.append("freespeed=\"").append(freeSpeed).append("\" ")
			.append("capacity=\"").append(capacity).append("\" ")
			.append("permlanes=\"").append(permLanes).append("\" ")
			// FIXED "1"
			.append("oneway=\"1\" ");
		if(!modes.isEmpty()){
			builder.append("modes=\"");
			for(String mode : modes){
				builder.append(mode).append(",");
			}
			// replace the last comma with quotes, there is nothing left
			// to delimit, only to close the list of values
			builder.replace(builder.length()-1, builder.length(), "\" ");
		}
		if(!Double.isNaN(volume)){
			builder.append("volume=\"").append(volume).append("\" ");
		}
		if(origId != null){
			builder.append("origid=\"").append(origId).append("\" ");
		}
		if(ntCategory != null){
			builder.append("nt_category=\"").append(ntCategory).append("\" ");
		}
		if(ntType != null){
			builder.append("nt_type=\"").append(ntType).append("\" ");
		}
		if(type != null){
			builder.append("type=\"").append(type).append("\" ");
		}
		builder.append("/>");
		
		return builder.toString();
	}
	
	/* (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if(!(obj instanceof Link)){
			return false;
		}
		Link other = (Link) obj;
		return this.id == other.id;
	}
	
	/* (non-Javadoc)
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return id;
	}
}
